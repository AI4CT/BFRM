# 气泡流场三维重建系统开发文档

## 目录
1. [系统概述](#1-系统概述)
2. [需求分析](#2-需求分析)
3. [系统设计](#3-系统设计)
4. [模块设计](#4-模块设计)
5. [接口设计](#5-接口设计)
6. [测试方案](#6-测试方案)
7. [部署与维护](#7-部署与维护)
8. [更新日志](#8-更新日志)
9. [附录](#9-附录)

## 1. 系统概述
本系统针对高速气泡流场研究需求，实现从多视角图像序列到三维流场结构的完整重建流程。系统包含7个核心模块，支持从原始数据采集到三维可视化交互的全链条处理。

## 2. 需求分析
### 2.1 功能性需求
- 数据采集：支持10,000+ fps高速相机数据流捕获
- 图像预处理：实现噪声消除、对比度增强、ROI提取
- 气泡检测：亚像素级精度识别，检测率>98%
- 三维重建：多视角匹配误差<0.1px
- 可视化：支持10^6+气泡实时渲染
- 性能优化：支持CUDA加速和多线程处理
- 轨迹跟踪：支持气泡ID关联和轨迹可视化

### 2.2 非功能性需求
| 指标类型 | 要求标准 |
|---------|---------|
| 处理速度 | 单帧处理时间<50ms @4K分辨率 |
| 内存管理 | 支持64GB+大容量数据缓存 |
| 精度要求 | Z轴重建误差<直径的5% |
| 兼容性  | 支持Basler/Phantom主流相机SDK |
| 硬件加速 | 支持NVIDIA GPU加速 |
| 轨迹长度 | 单个气泡最多保存100帧轨迹 |

## 3. 系统设计
### 3.1 架构设计
系统采用分层架构设计，主要包含以下层次：

1. 数据采集层
   - 相机控制与数据获取
   - 原始数据缓存管理
   - 数据格式转换

2. 图像处理层
   - 预处理模块
   - 目标检测模块
   - 特征提取模块

3. 三维重建层
   - 多视角匹配
   - 三维坐标计算
   - 轨迹重建

4. 应用层
   - 可视化界面
   - 用户交互
   - 数据导出

5. 性能优化层
   - CUDA加速
   - 多线程处理
   - 缓存管理

### 3.2 核心技术栈
- 开发语言：Python 3.8+
- 图像处理：OpenCV 4.8
- 深度学习：PyTorch 2.0, YOLO v8
- 三维重建：Open3D 0.17
- 可视化：VTK 9.2
- GUI框架：PyQt6
- 硬件加速：CUDA 11.8+

## 4. 模块设计
### 4.1 数据采集模块
#### 4.1.1 功能描述
- 支持多种型号高速相机接入
- 实时数据流采集与缓存
- 多相机同步触发控制

#### 4.1.2 核心类设计
```python
class DataAcquisition:
    def __init__(self, camera_params):
        """
        参数初始化
        camera_params: 相机参数配置字典
        """
        self.buffer_size = camera_params['buffer']
        self.fps = camera_params['max_fps']
        self.resolution = camera_params['resolution']
        
    def start_capture(self):
        """启动数据采集"""
        pass
        
    def stop_capture(self):
        """停止数据采集"""
        pass
```

### 4.2 图像预处理模块
#### 4.2.1 功能描述
- 图像去噪与增强
- 背景消除
- ROI提取
- 图像校正

#### 4.2.2 关键算法
```python
class ImagePreprocessor:
    def denoise(self, image):
        """
        非局部均值去噪
        """
        return cv2.fastNlMeansDenoising(image)
    
    def enhance_contrast(self, image):
        """
        自适应直方图均衡化
        """
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        return clahe.apply(image)
```

### 4.3 气泡检测模块
#### 4.3.1 功能描述
- 气泡轮廓提取
- 椭圆拟合
- 特征参数计算
- YOLO深度学习检测
- 气泡ID关联与轨迹跟踪

#### 4.3.2 实现方法
```python
class BubbleDetector:
    def detect(self, image):
        """
        气泡检测主函数
        """
        # 边缘检测
        edges = cv2.Canny(image, 50, 150)
        
        # 轮廓提取
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, 
                                     cv2.CHAIN_APPROX_NONE)
        
        # 椭圆拟合
        bubbles = []
        for contour in contours:
            if len(contour) >= 5:
                ellipse = cv2.fitEllipse(contour)
                bubbles.append(ellipse)
                
        return bubbles
        
    def track_bubbles(self, current_bubbles, previous_bubbles):
        """
        气泡轨迹跟踪
        """
        # 使用匈牙利算法进行ID关联
        if not previous_bubbles:
            return {i: i for i in range(len(current_bubbles))}
            
        # 计算距离矩阵
        cost_matrix = np.zeros((len(current_bubbles), len(previous_bubbles)))
        for i, current in enumerate(current_bubbles):
            for j, previous in enumerate(previous_bubbles):
                cost_matrix[i, j] = np.linalg.norm(
                    np.array(current['center']) - np.array(previous['center'])
                )
                
        # 使用匈牙利算法进行匹配
        row_ind, col_ind = linear_sum_assignment(cost_matrix)
        
        # 创建ID映射
        id_mapping = {}
        for i, j in zip(row_ind, col_ind):
            if cost_matrix[i, j] < 50:  # 距离阈值
                id_mapping[i] = previous_bubbles[j]['id']
            else:
                id_mapping[i] = max(b['id'] for b in previous_bubbles) + 1
                
        return id_mapping
```

### 4.4 三维重建模块
#### 4.4.1 功能描述
- 相机标定
- 特征点匹配
- 三维坐标计算
- 轨迹重建

#### 4.4.2 核心算法
```python
class Reconstructor3D:
    def __init__(self, camera_matrices):
        """
        初始化重建器
        camera_matrices: 相机内外参数
        """
        self.camera_matrices = camera_matrices
        
    def triangulate(self, points_2d):
        """
        三角测量计算三维坐标
        """
        points_3d = cv2.triangulatePoints(self.camera_matrices[0],
                                        self.camera_matrices[1],
                                        points_2d[0].T,
                                        points_2d[1].T)
        return points_3d
```

### 4.5 GUI界面模块
#### 4.5.1 功能描述
- 视频播放控制
- 气泡信息实时显示
- 轨迹可视化
- 参数调整界面
- 气泡轨迹绘制与管理

#### 4.5.2 核心类设计
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.init_ui()
        self.init_yolo_model()
        self.trajectories = {}  # 气泡轨迹字典
        
    def init_ui(self):
        """初始化用户界面"""
        # 创建主显示区域
        self.create_main_display_area()
        # 创建信息面板
        self.create_info_panel()
        # 添加视频控制
        self.add_video_controls()
        
    def update_display(self, frame_index):
        """更新显示内容"""
        # 处理当前帧
        processed_frame, frame_info = self.process_frame_with_yolo(
            self.frames[frame_index], frame_index)
        # 更新气泡信息显示
        self.update_bubble_info_display(frame_info)
        
    def process_frame_with_yolo(self, frame, frame_index):
        """使用YOLO处理帧"""
        # YOLO推理
        results = self.model(frame)
        
        # 处理检测结果
        processed_frame = frame.copy()
        frame_info = {}
        
        for r in results:
            # 处理每个检测到的气泡
            for i in range(len(r.obb)):
                # 获取气泡ID
                bubble_id = int(r.obb.id[i]) if hasattr(r.obb, 'id') else i
                
                # 更新气泡轨迹
                if bubble_id not in self.trajectories:
                    self.trajectories[bubble_id] = []
                self.trajectories[bubble_id].append(center)
                if len(self.trajectories[bubble_id]) > 100:
                    self.trajectories[bubble_id].pop(0)
                
                # 绘制轨迹
                for j in range(1, len(self.trajectories[bubble_id])):
                    start_point = self.trajectories[bubble_id][j-1]
                    end_point = self.trajectories[bubble_id][j]
                    cv2.line(processed_frame, start_point, end_point, color, 2)
                    
        return processed_frame, frame_info
```

### 4.6 性能优化模块
#### 4.6.1 功能描述
- CUDA加速YOLO推理
- 多线程预处理视频帧
- 智能缓存管理
- 轨迹数据优化

#### 4.6.2 核心实现
```python
class PerformanceOptimizer:
    def __init__(self):
        """初始化性能优化器"""
        # 检查CUDA可用性
        self.device = 'cuda:0' if torch.cuda.is_available() else 'cpu'
        # 创建线程池
        self.thread_pool = ThreadPoolExecutor(max_workers=4)
        # 初始化帧缓存
        self.frame_cache = {}
        # 初始化轨迹缓存
        self.trajectory_cache = {}
        
    def preprocess_frames(self, frames, current_index):
        """预处理帧"""
        # 计算需要预处理的帧范围
        start_idx = max(0, current_index - 5)
        end_idx = min(len(frames), current_index + 30)
        
        # 提交预处理任务到线程池
        futures = []
        for i in range(start_idx, end_idx):
            if i not in self.frame_cache:
                future = self.thread_pool.submit(self.process_frame, frames[i], i)
                futures.append((i, future))
                
        # 获取处理结果
        for i, future in futures:
            self.frame_cache[i] = future.result()
            
    def clean_cache(self, current_index, max_size=100):
        """清理过期缓存"""
        if len(self.frame_cache) < max_size:
            return
            
        # 计算需要保留的帧范围
        start_keep = max(0, current_index - 50)
        end_keep = current_index + 50
        
        # 删除范围外的缓存
        keys_to_delete = [k for k in self.frame_cache.keys() 
                         if k < start_keep or k > end_keep]
        for k in keys_to_delete:
            del self.frame_cache[k]
            
    def optimize_trajectories(self, trajectories, max_length=100):
        """优化轨迹数据"""
        # 限制轨迹长度
        for bubble_id in trajectories:
            if len(trajectories[bubble_id]) > max_length:
                trajectories[bubble_id] = trajectories[bubble_id][-max_length:]
                
        return trajectories
```

## 5. 接口设计
### 5.1 模块间接口
```python
class Pipeline:
    def __init__(self):
        self.preprocessor = ImagePreprocessor()
        self.detector = BubbleDetector()
        self.reconstructor = Reconstructor3D()
        self.optimizer = PerformanceOptimizer()
    
    def process_frame(self, frame):
        """
        单帧处理流程
        """
        # 预处理
        processed = self.preprocessor.process(frame)
        
        # 气泡检测
        bubbles = self.detector.detect(processed)
        
        # 三维重建
        coords_3d = self.reconstructor.reconstruct(bubbles)
        
        return coords_3d
        
    def process_video(self, video_path):
        """
        视频处理流程
        """
        # 加载视频
        frames = self.load_video(video_path)
        
        # 启动预处理
        self.optimizer.preprocess_frames(frames, 0)
        
        # 处理每一帧
        results = []
        for i, frame in enumerate(frames):
            # 从缓存获取或实时处理
            if i in self.optimizer.frame_cache:
                result = self.optimizer.frame_cache[i]
            else:
                result = self.process_frame(frame)
                
            results.append(result)
            
            # 预处理后续帧
            if i % 10 == 0:
                self.optimizer.preprocess_frames(frames, i + 10)
                self.optimizer.clean_cache(i)
                
        return results
```

### 5.2 数据接口
#### 5.2.1 气泡特征数据结构
```python
bubble_data = {
    'id': int,  # 气泡ID
    'frame_id': int,  # 帧序号
    'timestamp': float,  # 时间戳
    'position': {  # 三维坐标
        'x': float,
        'y': float,
        'z': float
    },
    'size': {  # 气泡尺寸
        'width': float,
        'height': float,
        'angle': float
    },
    'velocity': float,  # 速度
    'volume': float  # 体积
}
```

## 6. 测试方案
### 6.1 单元测试
- 模块功能测试
  - 气泡检测准确性测试
  - 轨迹跟踪连续性测试
  - 参数计算精度测试
- 边界条件测试
  - 极小/极大气泡检测测试
  - 高密度气泡场景测试
  - 轨迹交叉场景测试
- 异常处理测试
  - 无气泡场景测试
  - 图像噪声干扰测试
  - 气泡快速运动测试

### 6.2 集成测试
- 模块间接口测试
  - 检测与轨迹模块集成测试
  - 轨迹与可视化模块集成测试
- 数据流通测试
  - 多帧连续处理测试
  - 轨迹数据传递测试
- 性能压力测试
  - 大规模气泡场景测试
  - 长时间运行测试

### 6.3 系统测试
- 功能完整性测试
  - 完整处理流程测试
  - 轨迹可视化效果测试
- 稳定性测试
  - 长时间运行稳定性测试
  - 内存泄漏测试
- 精度验证测试
  - 轨迹准确性验证
  - 速度计算精度验证

### 6.4 性能测试
- CPU vs GPU性能对比测试
  - YOLO推理速度对比
  - 轨迹计算速度对比
- 多线程加速效果测试
  - 帧预处理加速效果
  - 轨迹计算并行效率
- 内存占用测试
  - 轨迹数据内存占用
  - 帧缓存内存占用
- 长时间运行稳定性测试
  - 内存泄漏监测
  - 轨迹数据一致性测试

## 7. 部署与维护
### 7.1 环境配置
```
# requirements.txt
numpy>=1.24.3
opencv-contrib-python>=4.8.0.76
torch>=2.0.1
torchvision>=0.15.0
open3d>=0.17.0
vtk>=9.2.0
pyqt6>=6.5.0
ultralytics>=8.0.0
concurrent-log-handler>=0.9.20
```

### 7.2 部署步骤
1. 环境准备
   ```bash
   pip install -r requirements.txt
   ```

2. CUDA安装（可选，推荐）
   ```bash
   # 安装CUDA Toolkit
   # 访问 https://developer.nvidia.com/cuda-downloads
   
   # 安装支持CUDA的PyTorch
   pip install torch torchvision --index-url https://download.pytorch.org/whl/cu118
   ```

3. 模型下载
   ```bash
   # 下载YOLO预训练模型
   python -c "from ultralytics import YOLO; YOLO('yolov8n.pt')"
   ```

4. 启动应用
   ```bash
   python main.py
   ```

## 8. 更新日志

### 2025年3月5日更新 (v1.2.0)
1. 性能优化
   - 添加CUDA加速支持，提高YOLO模型推理速度
   - 实现多线程预处理，提高视频播放流畅度
   - 添加智能帧缓存机制，减少重复计算

2. 界面优化
   - 移除了视频信息窗口，使界面更加简洁
   - 为气泡信息区域添加滚动条功能，支持大量气泡信息显示
   - 优化了气泡信息表格样式，添加行号列
   - 修复了字体警告问题

3. 功能改进
   - 视频循环播放时自动清空气泡轨迹，避免轨迹混乱
   - 气泡数量显示改为实时参数
   - 优化了表格头部固定功能，方便查看列名
   - 状态栏显示缓存状态和设备信息
   - 添加气泡轨迹跟踪与可视化功能，支持最多100帧历史轨迹
   - 实现气泡速度和体积实时计算

### 2025年2月25日更新 (v1.1.0)
1. 集成YOLO检测模型
   - 添加实时气泡检测功能
   - 支持气泡参数自动计算

2. 界面改进
   - 添加视频控制工具栏
   - 支持播放速度调整
   - 添加循环播放功能

## 9. 附录
### 9.1 参考文献
1. Lindken, R., & Merzkirch, W. (2002). A novel PIV technique for measurements in multiphase flows and its application to two-phase bubbly flows. Experiments in fluids, 33(6), 814-825.
2. Jocher, G., Chaurasia, A., & Qiu, J. (2023). YOLO by Ultralytics (Version 8.0.0) [Computer software]. https://github.com/ultralytics/ultralytics
3. Bradski, G. (2000). The OpenCV Library. Dr. Dobb's Journal of Software Tools.
4. Paszke, A., Gross, S., Massa, F., Lerer, A., Bradbury, J., Chanan, G., ... & Chintala, S. (2019). PyTorch: An imperative style, high-performance deep learning library. Advances in neural information processing systems, 32.

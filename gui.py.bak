import os
import time
from PyQt6.QtWidgets import (QMainWindow, QFileDialog, QPushButton, QLabel, 
                            QVBoxLayout, QWidget, QHBoxLayout, QProgressBar, 
                            QMessageBox, QMenuBar, QMenu, QStatusBar,
                            QFrame, QSizePolicy, QCheckBox, QGridLayout,
                            QScrollArea, QColorDialog, QSlider, QApplication
                            )
from PyQt6.QtCore import QTimer, Qt
from PyQt6.QtGui import (QMovie, QPalette, QColor, QFont, QPixmap, QImage, 
                        QIcon, QAction, QActionGroup)
import cv2
import imageio
import numpy as np

from image_processor import process_images
from video_processor import process_video, get_video_info
from animation_exporter import export_animation
from ellipse_fitting import draw_ellipse_on_image, draw_bounding_box_on_image, draw_rotated_rectangle
from reconstruction3d import reconstruct_3d

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("BFRM - 气泡流重建模型")
        self.setGeometry(100, 100, 1200, 800)
        self.setWindowIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/bubble.ico"))
        self.default_folder = "C:/DataSet_DOOR/dataset_yolov8_obb/test_bubble"
        self.result_root = "C:/Users/Administrator/Desktop/BFRM/results"
        self.output_folder = self.create_result_folder()
        
        # 存储内容标签的引用
        self.content_labels = {
            'flow': None,
            'detection': None,
            '3d': None,
            'info': None
        }
        
        self.frames = []
        self.frames_bbox = []
        self.frames_ellipse = []
        self.movies = {}  # 存储不同类型的QMovie对象
        self.current_labels = {}  # 存储不同类型的显示标签
        self.current_frame_index = 0  # 当前帧索引
        self.bubble_trail = []  # 存储气泡轨迹
        self.playback_speed = 1.0  # 播放速度倍率
        self.max_speed = 0  # 添加最大速度属性
        self.log_history = []  # 存储日志历史
        self.log_update_interval = 5  # 每5帧更新一次日志
        self.frame_info_dict = {}  # 存储每一帧的信息字典
        
        # 添加视频处理相关变量
        self.video_path = ""
        self.is_video_mode = False
        self.video_fps = 30  # 默认帧率
        self.is_playing = False  # 视频是否在播放
        
        # 添加视频帧显示定时器
        self.frame_timer = QTimer(self)
        self.frame_timer.timeout.connect(self.next_frame)
        
        # 添加3D可视化组件
        self.canvas_3d = None
        
        self.init_ui()
        
        self.movies = {
            'flow': QMovie(),
            'bbox': QMovie()
        }
        
        # 添加程序启动日志
        self.add_log("程序启动完成")
        self.add_log("提示: 可以通过'选择视频'按钮直接加载视频文件")
        self.add_log("提示: 视频加载后可以使用滑动条控制播放位置")
        self.add_log("提示: 可以使用'导出视频'按钮将处理后的视频保存")
    def create_result_folder(self):
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        folder = os.path.join(self.result_root, timestamp)
        os.makedirs(folder, exist_ok=True)
        return folder
    def init_ui(self):
        # 创建菜单栏
        self.create_menu_bar()
        
        # 创建状态栏
        self.statusBar = QStatusBar()
        self.setStatusBar(self.statusBar)
        self.statusBar.showMessage("就绪")
        
        # 主窗口部件
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        
        # 主布局
        main_layout = QVBoxLayout(main_widget)
        main_layout.setSpacing(15)  # 增加整体布局的间距
        main_layout.setContentsMargins(15, 15, 15, 15)  # 增加整体布局的边距
        
        # 按钮布局
        button_layout = QHBoxLayout()
        button_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
        button_layout.setSpacing(25)  # 增加按钮之间的间距
        button_layout.setContentsMargins(25, 20, 25, 20)  # 增加外边距
        
        # 选择文件夹按钮
        self.select_folder_btn = QPushButton('选择文件夹', self)
        self.select_folder_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/folder.png"))
        self.select_folder_btn.setStyleSheet("""
            QPushButton {
                font-size: 16px;
                padding: 10px 20px;
                background-color: #f0f0f0;
                border: 1px solid #ccc;
                border-radius: 4px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
            QPushButton:pressed {
                background-color: #d0d0d0;
            }
        """)
        self.select_folder_btn.clicked.connect(self.select_folder)
        button_layout.addWidget(self.select_folder_btn)
        
        # 添加选择视频文件按钮
        self.select_video_btn = QPushButton('选择视频', self)
        self.select_video_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/video.png"))
        self.select_video_btn.setStyleSheet("""
            QPushButton {
                font-size: 16px;
                padding: 10px 20px;
                background-color: #f0f0f0;
                border: 1px solid #ccc;
                border-radius: 4px;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
            QPushButton:pressed {
                background-color: #d0d0d0;
            }
        """)
        self.select_video_btn.clicked.connect(self.select_video)
        button_layout.addWidget(self.select_video_btn)
        
        # 处理按钮
        self.process_btn = QPushButton('处理', self)
        self.process_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/process.png"))
        self.process_btn.setStyleSheet("""
            QPushButton {
                font-size: 16px;
                padding: 10px 20px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:pressed {
                background-color: #3d8b40;
            }
        """)
        self.process_btn.clicked.connect(self.process_data)
        button_layout.addWidget(self.process_btn)
        
        # 导出视频按钮
        self.export_btn = QPushButton('导出视频', self)
        self.export_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/export.png"))
        self.export_btn.setStyleSheet("""
            QPushButton {
                font-size: 14px;
                padding: 8px 15px;
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 4px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
            QPushButton:pressed {
                background-color: #EF6C00;
            }
        """)
        self.export_btn.clicked.connect(self.export_video)
        self.export_btn.setEnabled(False)  # 初始禁用
        button_layout.addWidget(self.export_btn)
        
        # 重复播放复选框
        self.loop_checkbox = QCheckBox('循环播放', self)
        self.loop_checkbox.setChecked(True)
        self.loop_checkbox.setStyleSheet("""
            QCheckBox {
                font-size: 16px;
                padding: 10px;
            }
            QCheckBox::indicator {
                width: 20px;
                height: 20px;
            }
            QCheckBox::indicator:unchecked {
                border: 2px solid #999;
                border-radius: 4px;
                background-color: white;
            }
            QCheckBox::indicator:checked {
                border: 2px solid #4CAF50;
                border-radius: 4px;
                background-color: #4CAF50;
            }
        """)
        self.loop_checkbox.clicked.connect(self.toggle_loop)
        button_layout.addWidget(self.loop_checkbox)
        
        # 重新播放按钮
        self.replay_btn = QPushButton('重新播放', self)
        self.replay_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/replay.png"))  # 添加图标
        self.replay_btn.setStyleSheet("""
            QPushButton {
                font-size: 14px;
                padding: 8px 15px;
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.replay_btn.clicked.connect(self.replay_animations)
        button_layout.addWidget(self.replay_btn)
        
        # 添加暂停/开始按钮
        self.play_pause_btn = QPushButton('暂停', self)
        self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/pause.png"))
        self.play_pause_btn.setStyleSheet("""
            QPushButton {
                font-size: 14px;
                padding: 8px 15px;
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 4px;
                min-width: 100px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.play_pause_btn.clicked.connect(self.toggle_play_pause)
        button_layout.addWidget(self.play_pause_btn)
        
        button_layout.addStretch()  # 添加弹性空间，使按钮靠左对齐
        
        main_layout.addLayout(button_layout)
        
        # 添加帧控制滑动条
        self.frame_slider_layout = QHBoxLayout()
        self.frame_slider_layout.setContentsMargins(15, 0, 15, 0)
        
        self.frame_slider = QSlider(Qt.Orientation.Horizontal)
        self.frame_slider.setMinimum(0)
        self.frame_slider.setMaximum(100)  # 默认最大值，会在加载视频后更新
        self.frame_slider.setValue(0)
        self.frame_slider.setEnabled(False)  # 默认禁用
        self.frame_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                border: 1px solid #999999;
                height: 10px;
                background: #cccccc;
                margin: 2px 0;
                border-radius: 5px;
            }
            QSlider::handle:horizontal {
                background: #2196F3;
                border: 1px solid #1976D2;
                width: 16px;
                margin: -3px 0;
                border-radius: 8px;
            }
            QSlider::sub-page:horizontal {
                background: #4CAF50;
                border-radius: 5px;
            }
        """)
        self.frame_slider.valueChanged.connect(self.frame_slider_changed)
        
        self.frame_slider_layout.addWidget(self.frame_slider)
        
        self.frame_number_label = QLabel("0/0")
        self.frame_number_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.frame_number_label.setStyleSheet("""
            QLabel {
                font-size: 14px;
                padding: 5px;
                min-width: 80px;
            }
        """)
        self.frame_slider_layout.addWidget(self.frame_number_label)
        
        main_layout.addLayout(self.frame_slider_layout)
        
        # 进度条
        self.progressBar = QProgressBar()
        self.progressBar.setStyleSheet("""
            QProgressBar {
                border: 2px solid grey;
                border-radius: 5px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
                width: 15px;
            }
        """)
        main_layout.addWidget(self.progressBar)
        
        # 创建滚动区域
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        
        # 创建显示区域的容器
        display_widget = QWidget()
        display_layout = QHBoxLayout(display_widget)  # 使用水平布局
        display_layout.setSpacing(15)  # 增加间距
        display_layout.setContentsMargins(15, 15, 15, 15)  # 增加边距
        
        # 创建左侧显示区域容器
        left_container = QWidget()
        left_layout = QHBoxLayout(left_container)
        left_layout.setSpacing(15)  # 增加间距
        left_layout.setContentsMargins(0, 0, 0, 0)  # 移除边距
        
        # 横向排列显示区域
        self.labelFlow = self.create_display_label("气泡流图像")
        self.labelDetection = self.create_display_label("气泡实时检测")
        self.label3D = self.create_display_label("简化气泡流场")
        self.labelEmpty = self.create_display_label("气泡流场重建")
        
        # 设置左侧两个区域的最大宽度
        self.labelFlow.setMaximumWidth(400)
        self.labelDetection.setMaximumWidth(400)
        
        # 添加到左侧布局中
        left_layout.addWidget(self.labelFlow)
        left_layout.addWidget(self.labelDetection)
        left_layout.addWidget(self.label3D)
        left_layout.addWidget(self.labelEmpty)
        
        # 设置左侧布局的拉伸
        left_layout.setStretch(0, 1)  # 气泡流图像
        left_layout.setStretch(1, 1)  # 气泡实时检测
        left_layout.setStretch(2, 2)  # 简化气泡流场
        left_layout.setStretch(3, 2)  # 气泡流场重建
        
        # 创建信息面板
        info_panel = self.create_info_panel()
        
        # 将左侧显示区域和信息面板添加到主显示布局
        display_layout.addWidget(left_container, stretch=4)  # 左侧占4份
        display_layout.addWidget(info_panel, stretch=1)      # 信息面板占1份
        
        scroll_area.setWidget(display_widget)
        
        # 添加所有组件到主布局
        main_layout.addWidget(scroll_area, 1)  # 设置拉伸因子为1
        main_layout.addWidget(self.progressBar)
        
        # 设置窗口样式
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f0f0f0;
            }
            QLabel {
                color: #333333;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QFrame {
                border: 2px solid #cccccc;
                border-radius: 6px;
                background-color: white;
            }
        """)
    def create_menu_bar(self):
        menubar = self.menuBar()
        
        # 文件菜单
        file_menu = menubar.addMenu('文件')
        
        open_action = QAction('打开文件夹', self)
        open_action.setShortcut('Ctrl+O')
        open_action.triggered.connect(self.select_folder)
        file_menu.addAction(open_action)
        
        reset_action = QAction('重置', self)
        reset_action.setShortcut('Ctrl+R')
        reset_action.triggered.connect(self.reset_processing)
        file_menu.addAction(reset_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction('退出', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # 播放控制菜单
        playback_menu = menubar.addMenu('播放控制')
        
        # 播放速度子菜单
        speed_menu = QMenu('播放速度', self)
        playback_menu.addMenu(speed_menu)
        
        # 播放速度选项
        speeds = ['0.25x', '0.5x', '1.0x', '1.5x', '2.0x', '4.0x']
        speed_group = QActionGroup(self)
        speed_group.setExclusive(True)
        
        for speed in speeds:
            action = QAction(speed, self)
            action.setCheckable(True)
            if speed == '1.0x':
                action.setChecked(True)
            speed_group.addAction(action)
            speed_menu.addAction(action)
        
        speed_group.triggered.connect(self.change_playback_speed)
        
        # 视图菜单
        view_menu = menubar.addMenu('视图')
        
        # 添加颜色设置子菜单
        color_menu = QMenu('颜色设置', self)
        view_menu.addMenu(color_menu)
        
        # 创建颜色图标
        def create_color_icon(color):
            pixmap = QPixmap(16, 16)
            pixmap.fill(QColor(color))
            return QIcon(pixmap)
        
        liquid_color_action = QAction(create_color_icon('#0000FF'), '液相颜色', self)
        bubble_color_action = QAction(create_color_icon('#FF0000'), '气泡颜色', self)
        
        liquid_color_action.triggered.connect(self.change_liquid_color)
        bubble_color_action.triggered.connect(self.change_bubble_color)
        
        color_menu.addAction(liquid_color_action)
        color_menu.addAction(bubble_color_action)
        
        # 字体大小子菜单
        font_size_menu = QMenu('标题字体大小', self)
        view_menu.addMenu(font_size_menu)
        
        # 标题字体大小选项
        font_sizes = ['小 (18px)', '中 (22px)', '大 (26px)', '较大 (30px)']
        font_size_group = QActionGroup(self)
        font_size_group.setExclusive(True)
        
        for size in font_sizes:
            action = QAction(size, self)
            action.setCheckable(True)
            if size == '中 (22px)':
                action.setChecked(True)
            font_size_group.addAction(action)
            font_size_menu.addAction(action)
        
        font_size_group.triggered.connect(self.change_title_font_size)
        
        # 内容字体大小子菜单
        content_font_menu = QMenu('内容字体大小', self)
        view_menu.addMenu(content_font_menu)
        
        # 内容字体大小选项
        content_sizes = ['小 (14px)', '中 (16px)', '大 (18px)', '较大 (20px)']
        content_size_group = QActionGroup(self)
        content_size_group.setExclusive(True)
        
        for size in content_sizes:
            action = QAction(size, self)
            action.setCheckable(True)
            if size == '中 (16px)':
                action.setChecked(True)
            content_size_group.addAction(action)
            content_font_menu.addAction(action)
        
        content_size_group.triggered.connect(self.change_content_font_size)
        
        # 帮助菜单
        help_menu = menubar.addMenu('帮助')
        
        about_action = QAction('关于', self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
    def change_title_font_size(self, action):
        """更改标题字体大小"""
        size_map = {
            '小 (18px)': 18,
            '中 (22px)': 22,
            '大 (26px)': 26,
            '较大 (30px)': 30
        }
        
        size = size_map[action.text()]
        
        # 更新所有标题标签的字体大小
        title_labels = [
            self.labelFlow.layout().itemAt(0).widget(),
            self.labelDetection.layout().itemAt(0).widget(),
            self.label3D.layout().itemAt(0).widget(),
            self.labelEmpty.layout().itemAt(0).widget()
        ]
        
        for label in title_labels:
            title_font = label.font()
            title_font.setPointSize(size)
            label.setFont(title_font)
            label.setStyleSheet(f"""
                QLabel {{
                    font-size: {size}px;
                    font-weight: bold;
                    color: #333333;
                    padding: 8px;
                }}
            """)
        
        self.add_log(f"更改标题字体大小为: {action.text()}")

    def change_content_font_size(self, action):
        """更改内容字体大小"""
        size_map = {
            '小 (14px)': 14,
            '中 (16px)': 16,
            '大 (18px)': 18,
            '较大 (20px)': 20
        }
        
        size = size_map[action.text()]
        
        # 更新信息显示和日志标签的字体大小
        if 'info' in self.content_labels and self.content_labels['info'] is not None:
            self.content_labels['info'].setStyleSheet(f"""
                QLabel {{
                    background-color: white;
                    border: 1px solid #cccccc;
                    border-radius: 4px;
                    padding: 10px;
                    font-family: Consolas, Monaco, monospace;
                    font-size: {size}px;
                    min-height: 100px;
                }}
            """)
        
        if hasattr(self, 'log_label'):
            self.log_label.setStyleSheet(f"""
                QLabel {{
                    background-color: white;
                    border: 1px solid #cccccc;
                    border-radius: 4px;
                    padding: 10px;
                    font-family: Consolas, Monaco, monospace;
                    font-size: {size}px;
                    min-height: 100px;
                }}
            """)
        
        self.add_log(f"更改内容字体大小为: {action.text()}")
    def create_display_label(self, title):
        """创建显示区域，返回容器框架，并保存内容标签的引用"""
        container = QFrame()
        container.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        container.setLineWidth(2)
        container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)  # 居中对齐
        
        # 创建标题标签
        title_label = QLabel(title)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("""
            QLabel {
                font-size: 24px;
                font-weight: bold;
                color: #333333;
                padding: 10px;
                background-color: #f5f5f5;
                border-bottom: 2px solid #ddd;
                border-radius: 4px;
            }
        """)
        layout.addWidget(title_label)
        
        # 根据不同的标题创建不同的内容
        if title == "简化气泡流场":
            # 创建3D画布
            self.canvas_3d = reconstruct_3d(None, None)
            self.canvas_3d.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            self.canvas_3d.setMinimumSize(50, 50)
            layout.addWidget(self.canvas_3d, 1)
            self.content_labels['3d'] = self.canvas_3d
        else:
            # 创建普通内容标签
            content_label = QLabel()
            content_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            content_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            content_label.setStyleSheet("""
                QLabel {
                    background-color: transparent;
                    border: none;
                }
            """)
            layout.addWidget(content_label, 1)
            
            # 根据标题保存标签引用
            if title == "气泡流图像":
                self.content_labels['flow'] = content_label
            elif title == "气泡实时检测":
                self.content_labels['detection'] = content_label
            elif title == "":
                self.content_labels['info'] = content_label
        
        return container
    def reset_processing(self):
        """重置处理状态"""
        self.frames = []
        self.frames_bbox = []
        self.frames_ellipse = []
        self.progressBar.setValue(0)
        
        # 停止所有动画
        for movie in self.movies.values():
            if movie:
                movie.stop()
        
        # 清空显示
        for label in self.content_labels.values():
            if label is not None:
                label.clear()
            
        self.statusBar.showMessage('已重置')
        self.output_folder = self.create_result_folder()
        self.add_log("重置处理状态")
    def show_about(self):
        """显示关于对话框"""
        QMessageBox.about(self, 
            "关于BFRM",
            "气泡流重建模型 (BFRM)\n\n"
            "版本: 1.0.0\n"
            "作者: YBD\n\n"
            "用于气泡流图像处理与3D重建的软件工具。"
        )
    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "选择数据文件夹", self.default_folder)
        if folder:
            # 先停止任何正在播放的内容
            self.stop_playback()
            
            # 重置视频模式标志
            self.is_video_mode = False
            self.video_path = ""
            
            # 检查文件夹中是否包含必要的文件
            csv_files = [f for f in os.listdir(folder) if f.endswith('.csv')]
            image_files = [f for f in os.listdir(folder) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
            
            if not csv_files:
                QMessageBox.warning(self, "文件缺失", 
                    "所选文件夹中未找到CSV文件！\n"
                    "请确保文件夹中包含气泡数据的CSV文件。")
                return
            
            if not image_files:
                QMessageBox.warning(self, "文件缺失", 
                    "所选文件夹中未找到图像文件！\n"
                    "请确保文件夹中包含气泡图像文件（PNG、JPG或JPEG格式）。")
                return
            
            self.default_folder = folder
            self.statusBar.showMessage(f"已选择文件夹: {folder}")
            self.add_log(f"选择数据文件夹: {folder}")
            self.add_log(f"找到 {len(csv_files)} 个CSV文件和 {len(image_files)} 个图像文件")
            
            # 清空之前的显示
            for label in self.content_labels.values():
                if label:
                    label.clear()
            
            self.process_btn.setEnabled(True)  # 启用处理按钮
            self.process_data()
    def select_video(self):
        """选择视频文件"""
        video_file, _ = QFileDialog.getOpenFileName(
            self, 
            "选择视频文件", 
            os.path.dirname(self.default_folder), 
            "视频文件 (*.mp4 *.avi *.mov *.mkv)"
        )
        
        if video_file:
            try:
                # 先停止任何正在播放的内容
                self.stop_playback()
                
                # 清空之前的模式标记
                self.is_video_mode = True
                self.video_path = video_file
                
                # 获取视频信息
                video_info = get_video_info(video_file)
                self.video_fps = video_info['fps']
                
                self.statusBar.showMessage(f"已选择视频: {os.path.basename(video_file)}")
                self.add_log(f"选择视频文件: {video_file}")
                self.add_log(f"视频信息: {video_info['frame_count']} 帧, {video_info['fps']} FPS, 分辨率: {video_info['width']}x{video_info['height']}")
                
                # 清空之前的显示
                for label in self.content_labels.values():
                    if label:
                        label.clear()
                
                self.process_btn.setEnabled(True)  # 启用处理按钮
                
                # 自动开始处理
                self.process_data()
                
            except Exception as e:
                QMessageBox.critical(self, "错误", f"无法读取视频文件: {str(e)}")
                self.video_path = ""
                self.is_video_mode = False
    def process_data(self):
        if self.is_video_mode and self.video_path:
            self.process_video_data()
        elif self.default_folder:
            self.process_folder_data()
        else:
            self.statusBar.showMessage('请先选择文件夹或视频文件')
            self.add_log("错误：未选择数据文件夹或视频文件")
            QMessageBox.warning(self, "错误", "请先选择包含数据的文件夹或视频文件！")
    
    def process_video_data(self):
        """处理视频文件数据"""
        try:
            self.progressBar.setValue(0)
            self.add_log("开始处理视频数据...")
            
            # 清空气泡轨迹和帧信息字典
            self.bubble_trail = []
            self.frame_info_dict = {}
            
            # 处理视频，得到帧序列
            try:
                result = process_video(
                    self.video_path, 
                    self.output_folder,
                    lambda p: self.progressBar.setValue(int(p * 0.8)))
                )
                
                self.frames = result[0]
                frame_count = result[1]
                self.video_fps = result[2]
                
                # 为第二个区域创建边界框帧（在这里我们只是复制原始帧）
                self.frames_bbox = self.frames.copy()
                
            except Exception as e:
                QMessageBox.critical(self, "处理错误", f"处理视频时出错：{str(e)}")
                self.statusBar.showMessage("处理出错")
                return
                
            self.add_log(f"视频帧序列生成完成，共 {len(self.frames)} 帧，帧率: {self.video_fps} FPS")
            print(f"总帧数: {len(self.frames)}, 帧率: {self.video_fps}")  # 调试输出
            
            # 启用并设置滑动条
            self.frame_slider.setEnabled(True)
            self.frame_slider.setMaximum(len(self.frames) - 1)
            self.frame_slider.setValue(0)
            self.frame_number_label.setText(f"1/{len(self.frames)}")
            
            # 显示第一帧
            self.current_frame_index = 0
            self.update_display(0)
            
            # 设置播放按钮状态
            self.play_pause_btn.setText('播放')
            self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/play.png"))
            self.is_playing = False
            
            # 启用导出按钮
            self.export_btn.setEnabled(True)
            
            self.progressBar.setValue(100)
            self.statusBar.showMessage("处理完成")
            self.add_log("所有处理步骤已完成")
            
        except Exception as e:
            error_msg = f"错误: {str(e)}"
            self.add_log(error_msg)
            self.statusBar.showMessage("处理出错")
            QMessageBox.critical(self, "错误", error_msg)
            self.progressBar.setValue(0)
            import traceback
            traceback.print_exc()
    
    def process_folder_data(self):
        """处理文件夹数据（原有功能）"""
        if not self.default_folder:
            self.statusBar.showMessage('请先选择文件夹')
            self.add_log("错误：未选择数据文件夹")
            QMessageBox.warning(self, "错误", "请先选择包含数据的文件夹！")
            return
            
        try:
            self.progressBar.setValue(0)
            self.add_log("开始处理数据...")
            
            # 清空气泡轨迹和帧信息字典
            self.bubble_trail = []
            self.frame_info_dict = {}
            
            # 步骤 1: 处理气泡图像，得到连续气泡流图像序列和对应数据
            try:
                self.frames, self.filtered_data = process_images(
                    self.default_folder, 
                    self.output_folder,
                    lambda p: self.progressBar.setValue(int(p * 0.4)))
                )
                    
            except FileNotFoundError as e:
                QMessageBox.critical(self, "文件错误", 
                    f"处理数据时出错：{str(e)}\n\n"
                    "请确保选择的文件夹中包含：\n"
                    "1. 气泡数据的CSV文件\n"
                    "2. 对应的图像文件")
                self.statusBar.showMessage("处理出错：文件缺失")
                return
            except Exception as e:
                QMessageBox.critical(self, "处理错误", f"处理图像时出错：{str(e)}")
                self.statusBar.showMessage("处理出错")
                return
                
            self.add_log(f"气泡流图像序列生成完成，共 {len(self.frames)} 帧")
            print(f"总帧数: {len(self.frames)}")  # 调试输出
            
            # 预处理每一帧的信息
            pixel_scale = 0.080128  # 像素尺度（毫米/像素）
            dt = 0.0001  # 帧间隔时间（秒）
            
            # 初始化边界框图像列表
            self.frames_bbox = []
            
            total_frames = len(self.frames)
            self.add_log(f"原始图像序列帧数: {total_frames}")
            
            # 确保frames_bbox和frames的长度相同
            for i in range(total_frames):
                frame = self.frames[i]
                row = self.filtered_data.iloc[i]  # 直接获取行数据
                
                # 更新气泡轨迹
                if i < len(self.filtered_data):
                    self.bubble_trail.append(row)
                current_trail = self.bubble_trail.copy()
                
                # 添加边界框图像
                bbox_frame = self.draw_bounding_box_on_image(frame.copy(), row, current_trail)
                self.frames_bbox.append(bbox_frame)
                
                # 计算位置
                x_pos = (row['x0'] + 64) * pixel_scale
                y_pos = (row['y0'] + 64) * pixel_scale
                
                # 计算速度和加速度
                vx = vy = ax = ay = v_total = a_total = 0
                vx_ms = vy_ms = v_total_ms = 0
                
                if i > 0:
                    prev_row = self.filtered_data.iloc[i-1]
                    dx = (row['x0'] - prev_row['x0']) * pixel_scale
                    dy = (row['y0'] - prev_row['y0']) * pixel_scale
                    
                    if i == len(self.frames) - 1:
                        last_dx = (prev_row['x0'] - self.filtered_data.iloc[i-2]['x0']) * pixel_scale
                        last_dy = (prev_row['y0'] - self.filtered_data.iloc[i-2]['y0']) * pixel_scale
                        if abs(dy - last_dy) > abs(last_dy) * 2:
                            dy = last_dy
                            dx = last_dx
                    
                    vx = dx / dt
                    vy = dy / dt
                    v_total = np.sqrt(vx**2 + vy**2)
                    
                    vx_ms = vx / 1000
                    vy_ms = vy / 1000
                    v_total_ms = v_total / 1000
                    
                    if i > 1:
                        prev_prev_row = self.filtered_data.iloc[i-2]
                        dvx = (vx - (row['x0'] - prev_prev_row['x0']) * pixel_scale / dt) / dt
                        dvy = (vy - (row['y0'] - prev_prev_row['y0']) * pixel_scale / dt) / dt
                        ax = dvx
                        ay = dvy
                        a_total = np.sqrt(ax**2 + ay**2)
                
                # 存储当前帧的信息
                self.frame_info_dict[i] = {
                    'frame_number': i + 1,
                    'total_frames': len(self.frames),
                    'position': (x_pos, y_pos),
                    'velocity': (vx_ms, vy_ms, v_total_ms),
                    'acceleration': (ax/1000, ay/1000, a_total/1000),
                    'size': (row['w_r'] * pixel_scale, row['h_r'] * pixel_scale),
                    'angle': row['theta']
                }
                
                # 更新进度
                self.progressBar.setValue(40 + int(20 * (i + 1) / len(self.frames)))
                
                # 打印处理进度
                if (i + 1) % 10 == 0:
                    self.add_log(f"已处理 {i + 1}/{len(self.frames)} 帧")
            
            # 检查帧数是否一致
            bbox_frames = len(self.frames_bbox)
            
            self.add_log(f"边界框标注序列帧数: {bbox_frames}")
            
            if total_frames != bbox_frames:
                error_msg = f"帧数不一致！原始: {total_frames}, 边界框: {bbox_frames}"
                self.add_log(f"错误: {error_msg}")
                QMessageBox.critical(self, "帧数错误", error_msg)
                return
            
            self.add_log("数据预处理完成，所有序列帧数一致")
            
            # 步骤 3: 导出动画文件
            self.add_log("正在导出动画文件...")
            self.export_animations()
            
            # 步骤 4: 在UI中显示动画
            self.add_log("正在更新界面显示...")
            self.display_animations()
            
            self.progressBar.setValue(100)
            self.statusBar.showMessage("处理完成")
            self.add_log("所有处理步骤已完成")
            
        except Exception as e:
            error_msg = f"错误: {str(e)}"
            self.add_log(error_msg)
            self.statusBar.showMessage("处理出错")
            QMessageBox.critical(self, "错误", error_msg)
            self.progressBar.setValue(0)
            import traceback
            traceback.print_exc()
    def display_animations(self):
        """在UI中显示动画"""
        try:
            # 如果是视频模式，直接使用原始帧显示
            if self.is_video_mode:
                # 显示第一帧
                self.current_frame_index = 0
                self.update_display(0)
                return
                
            # 以下是原有的GIF动画处理模式
            # 设置动画文件路径
            mp4_paths = {
                '气泡流图像': os.path.join(self.output_folder, 'bubble_flow.mp4')
            }
            
            if len(self.frames_bbox) > 0:
                mp4_paths['边界框标注'] = os.path.join(self.output_folder, 'bubble_flow_bbox.mp4')
            
            # 检查所有MP4文件是否存在
            for title, mp4_path in mp4_paths.items():
                if not os.path.exists(mp4_path):
                    error_msg = f"找不到MP4文件: {mp4_path}"
                    print(f"[错误] {error_msg}")
                    QMessageBox.critical(self, "错误", error_msg)
                    return
            
            # 从MP4创建GIF文件
            self.add_log("从MP4创建临时GIF文件用于显示...")
            gif_paths = {}
            
            for title, mp4_path in mp4_paths.items():
                # 创建临时GIF文件
                gif_path = mp4_path.replace('.mp4', '.gif')
                
                # 使用imageio读取视频并创建GIF
                try:
                    frames = []
                    # 限制帧数，避免GIF文件过大
                    max_frames = 100
                    reader = imageio.get_reader(mp4_path)
                    fps = reader.get_meta_data()['fps']
                    total_frames = reader.count_frames()
                    step = max(1, total_frames // max_frames)
                    
                    for i, frame in enumerate(reader):
                        if i % step == 0:
                            frames.append(frame)
                            
                    reader.close()
                    
                    # 保存为GIF
                    imageio.mimsave(gif_path, frames, fps=fps/step)
                    gif_paths[title] = gif_path
                    
                except Exception as e:
                    error_msg = f"从MP4创建GIF文件时出错: {str(e)}"
                    print(f"[错误] {error_msg}")
                    QMessageBox.critical(self, "错误", error_msg)
                    return
            
            # 清理现有的动画
            for movie in self.movies.values():
                if movie and movie.state() == QMovie.MovieState.Running:
                    movie.stop()
            self.movies.clear()
            
            # 创建所有动画对象并检查帧数
            frame_counts = {}
            for title, gif_path in gif_paths.items():
                movie = QMovie(gif_path)
                if not movie.isValid():
                    error_msg = f"无效的GIF文件: {gif_path}"
                    print(f"[错误] {error_msg}")
                    QMessageBox.critical(self, "错误", error_msg)
                    return
                
                # 获取总帧数
                movie.jumpToFrame(0)
                frame_counts[title] = movie.frameCount()
                self.movies[title] = movie
            
            # 记录完成的动画数量，用于同步控制
            self.finished_animations = 0
            
            # 定义一个通用函数，设置标签的大小变化事件处理，确保自动调整且保持宽高比
            def set_label_resize_handler(label, movie):
                movie.jumpToFrame(0)
                original_size = movie.currentImage().size()
                def update_movie_size():
                    label_size = label.size()
                    scaled_size = original_size.scaled(
                        label_size.width() - 10,
                        label_size.height() - 10,
                        Qt.AspectRatioMode.KeepAspectRatio
                    )
                    movie.setScaledSize(scaled_size)
                    label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                label.update_movie_size = update_movie_size
                def resize_event(event):
                    QLabel.resizeEvent(label, event)
                    label.update_movie_size()
                label.resizeEvent = resize_event
                # 初始化大小
                update_movie_size()
            
            # 设置动画显示
            for title, movie in self.movies.items():
                if title == '气泡流图像':
                    label = self.content_labels['flow']
                elif title == '边界框标注':
                    label = self.content_labels['detection']
                else:
                    label = None
                
                if label:
                    # 设置标签居中
                    label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                    # 为标签设置统一的大小变化事件处理：随窗口自动调整且保持比例
                    set_label_resize_handler(label, movie)
                    
                    # 设置动画完成时的处理函数
                    def create_finished_handler(m):
                        def handler():
                            self.finished_animations += 1
                            # 当所有动画都完成时
                            if self.finished_animations >= len(self.movies):
                                if self.loop_checkbox.isChecked():
                                    # 重置计数器并重新启动所有动画
                                    self.finished_animations = 0
                                    for m2 in self.movies.values():
                                        m2.start()
                                else:
                                    # 停止所有动画并更新播放按钮状态
                                    for m2 in self.movies.values():
                                        m2.stop()
                                    self.play_pause_btn.setText('播放')
                                    self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/play.png"))
                                    self.add_log("动画播放完成")
                        return handler
                    
                    movie.finished.connect(create_finished_handler(movie))
                    
                    # 连接帧变化信号到更新显示函数（仅对气泡流图像）
                    if title == '气泡流图像':
                        movie.frameChanged.connect(lambda: self.update_display(movie.currentFrameNumber()))
                    
                    # 设置动画速度
                    movie.setSpeed(int(100 * self.playback_speed))
                    
                    # 分配动画到标签
                    label.setMovie(movie)
                    
                    # 启动动画
                    movie.start()
            
            print("动画显示初始化完成")
            self.add_log(f"所有动画帧数一致: {list(frame_counts.values())[0]} 帧")
            
        except Exception as e:
            error_msg = f"显示动画时出错: {str(e)}"
            print(f"[错误] {error_msg}")
            QMessageBox.critical(self, "错误", error_msg)
            import traceback
            traceback.print_exc()

    def update_display(self, frame_index):
        """更新指定帧的显示"""
        try:
            # 如果是视频模式，直接使用帧索引更新图像
            if self.is_video_mode and frame_index < len(self.frames):
                # 获取当前帧
                frame = self.frames[frame_index]
                frame_bbox = self.frames_bbox[frame_index] if frame_index < len(self.frames_bbox) else None
                
                # 将帧转换为QImage显示
                height, width, channel = frame.shape
                bytes_per_line = 3 * width
                q_img = QImage(frame.data, width, height, bytes_per_line, QImage.Format.Format_RGB888).rgbSwapped()
                pixmap = QPixmap.fromImage(q_img)
                
                # 更新第一个区域
                if self.content_labels['flow']:
                    self.content_labels['flow'].setPixmap(pixmap)
                
                # 更新第二个区域
                if self.content_labels['detection'] and frame_bbox is not None:
                    q_img_bbox = QImage(frame_bbox.data, width, height, bytes_per_line, QImage.Format.Format_RGB888).rgbSwapped()
                    pixmap_bbox = QPixmap.fromImage(q_img_bbox)
                    self.content_labels['detection'].setPixmap(pixmap_bbox)
                
                # 更新帧号
                self.frame_number_label.setText(f"{frame_index + 1}/{len(self.frames)}")
            else:
                # 原有模式的信息更新
                self.update_info_display(frame_index)
                
                # 更新3D可视化
                if hasattr(self, 'filtered_data') and frame_index < len(self.filtered_data) and self.canvas_3d:
                    current_row = self.filtered_data.iloc[frame_index]
                    self.canvas_3d.update_bubble(current_row)
        except Exception as e:
            print(f"更新显示时出错: {str(e)}")
            import traceback
            traceback.print_exc()
            
    def update_info_display(self, frame_index):
        """更新信息显示面板"""
        try:
            if frame_index not in self.frame_info_dict:
                return
            
            frame_info = self.frame_info_dict[frame_index]
            
            # 更新实时信息显示
            info_entry = (
                f"帧: {frame_info['frame_number']}/{frame_info['total_frames']}\n\n"
                f"位置: ({frame_info['position'][0]:.2f}, {frame_info['position'][1]:.2f}) mm\n\n"
                f"速度:\n"
                f"  Vx = {frame_info['velocity'][0]:.3f} m/s\n"
                f"  Vy = {frame_info['velocity'][1]:.3f} m/s\n"
                f"  V  = {frame_info['velocity'][2]:.3f} m/s\n\n"
                f"加速度:\n"
                f"  ax = {frame_info['acceleration'][0]:.3f} m/s²\n"
                f"  ay = {frame_info['acceleration'][1]:.3f} m/s²\n"
                f"  a  = {frame_info['acceleration'][2]:.3f} m/s²\n\n"
                f"气泡尺寸: {frame_info['size'][0]:.2f}×{frame_info['size'][1]:.2f} mm\n"
                f"角度: {frame_info['angle']:.2f}°\n\n"
                f"播放速度: {self.playback_speed:.2f}x"
            )
            
            self.info_label.setText(info_entry)
            self.info_label.repaint()
            
        except Exception as e:
            print(f"[错误] 更新信息显示时出错: {str(e)}")
            import traceback
            traceback.print_exc()

    def replay_animations(self):
        """重新播放动画"""
        if self.is_video_mode:
            self.stop_playback()
            self.start_playback()
        else:
            # 原有的处理逻辑
            # 重置帧索引
            self.current_frame_index = 0
            
            for title, movie in self.movies.items():
                if movie and movie.isValid():
                    movie.stop()
                    movie.start()
            
            # 更新播放按钮状态
            self.play_pause_btn.setText('暂停')
            self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/pause.png"))
        
        self.add_log("重新开始播放")
    
    def toggle_play_pause(self):
        """切换播放/暂停状态"""
        if self.is_video_mode:
            if self.is_playing:
                self.pause_playback()
            else:
                self.start_playback()
        else:
            # 原有的动画处理逻辑
            is_paused = False
            for movie in self.movies.values():
                if movie and movie.isValid():
                    if movie.state() == QMovie.MovieState.Running:
                        movie.setPaused(True)
                        is_paused = True
                    else:
                        movie.setPaused(False)
                        is_paused = False
            
            if is_paused:
                self.play_pause_btn.setText('播放')
                self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/play.png"))
            else:
                self.play_pause_btn.setText('暂停')
                self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/pause.png"))
            
            self.add_log(f"动画{'暂停' if is_paused else '播放'}")
    
    def frame_slider_changed(self, value):
        """滑动条值改变时的处理函数"""
        if not self.is_video_mode or not self.frames or len(self.frames) == 0:
            return
            
        # 如果视频正在播放，先暂停
        if self.is_playing:
            self.pause_playback()
        
        # 计算帧索引
        frame_index = min(value, len(self.frames) - 1)
        self.current_frame_index = frame_index
        
        # 更新帧数显示
        self.frame_number_label.setText(f"{frame_index + 1}/{len(self.frames)}")
        
        # 更新显示
        self.update_display(frame_index)
    
    def export_animations(self):
        """导出GIF和MP4动画"""
        try:
            # 检查帧数是否一致
            frame_counts = {
                '气泡流图像': len(self.frames)
            }
            
            if len(self.frames_bbox) > 0:
                frame_counts['边界框标注'] = len(self.frames_bbox)
            
            if len(set(frame_counts.values())) != 1:
                error_msg = "帧数不一致:\n"
                for name, count in frame_counts.items():
                    error_msg += f"{name}: {count} 帧\n"
                raise ValueError(error_msg)
            
            # 设置动画文件路径
            mp4_paths = {
                '气泡流图像': os.path.join(self.output_folder, 'bubble_flow.mp4')
            }
            
            if len(self.frames_bbox) > 0:
                mp4_paths['边界框标注'] = os.path.join(self.output_folder, 'bubble_flow_bbox.mp4')
            
            # 仅导出MP4
            frames_dict = {
                '气泡流图像': self.frames
            }
            
            if len(self.frames_bbox) > 0:
                frames_dict['边界框标注'] = self.frames_bbox
            
            total_exports = len(frames_dict)  # 只导出MP4
            current_export = 0
            
            # 使用原始视频的帧率（如果是视频模式）
            fps = self.video_fps if self.is_video_mode and self.video_fps > 0 else 30
            
            for title, frames in frames_dict.items():
                # 保存MP4
                print(f"正在导出{title} MP4...")
                height, width = frames[0].shape[:2]
                fourcc = cv2.VideoWriter_fourcc(*'mp4v')
                out = cv2.VideoWriter(mp4_paths[title], fourcc, fps, (width, height))
                
                for frame in frames:
                    out.write(frame)
                out.release()
                
                current_export += 1
                self.progressBar.setValue(80 + int(20 * current_export / total_exports))
            
            self.add_log("视频文件导出完成")
            print("所有MP4文件导出完成")
            
        except Exception as e:
            error_msg = f"导出视频文件时出错: {str(e)}"
            print(error_msg)
            QMessageBox.critical(self, "错误", error_msg)
            raise Exception(error_msg)
    def toggle_loop(self):
        """切换动画循环播放状态"""
        is_loop = self.loop_checkbox.isChecked()
        
        # 只更新循环状态，不自动开始播放
        for movie in self.movies.values():
            if movie and movie.isValid():
                # 如果动画已经结束，不要自动重新开始播放
                if movie.state() == QMovie.MovieState.NotRunning:
                    movie.jumpToFrame(0)  # 只重置到第一帧
                    
        self.add_log(f"{'启用' if is_loop else '禁用'}循环播放")
        
    def resizeEvent(self, event):
        """处理窗口大小变化事件"""
        super().resizeEvent(event)
        # 更新所有动画的大小
        for label in self.content_labels.values():
            if label and hasattr(label, 'movie') and label.movie() and hasattr(label, 'update_movie_size'):
                label.update_movie_size()

    def change_playback_speed(self, action):
        """更改播放速度"""
        speed_text = action.text()
        new_speed = float(speed_text.replace('x', ''))
        
        # 如果速度改变，更新播放
        if self.playback_speed != new_speed:
            self.playback_speed = new_speed
            
            # 如果视频正在播放，重新设置定时器
            if self.is_video_mode and self.is_playing:
                interval = int(1000 / (self.video_fps * self.playback_speed))
                self.frame_timer.start(interval)
            
            # 更新所有动画的播放速度（非视频模式）
            for movie in self.movies.values():
                if movie and movie.isValid():
                    movie.setSpeed(int(100 * self.playback_speed))
        
        self.statusBar.showMessage(f"播放速度: {speed_text}")
        self.add_log(f"更改播放速度为: {speed_text}")
    
    def create_info_panel(self):
        """创建信息显示面板"""
        info_panel = QFrame()
        info_panel.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Raised)
        info_panel.setLineWidth(2)
        info_panel.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Expanding)
        info_panel.setMinimumWidth(400)  # 增加最小宽度
        info_panel.setMaximumWidth(500)  # 增加最大宽度
        
        layout = QVBoxLayout(info_panel)
        layout.setContentsMargins(10, 10, 10, 10)  # 增加边距
        layout.setSpacing(10)  # 增加间距
        
        # 实时信息部分
        info_container = QWidget()
        info_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        info_layout = QVBoxLayout(info_container)
        info_layout.setContentsMargins(0, 0, 0, 0)
        info_layout.setSpacing(0)
        
        info_title = QLabel("实时信息")
        info_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        info_title.setStyleSheet("""
            QLabel {
                font-size: 20px;
                font-weight: bold;
                color: #333333;
                padding: 8px;
                background-color: #f5f5f5;
                border-bottom: 1px solid #ddd;
                border-radius: 4px;
            }
        """)
        info_layout.addWidget(info_title)
        
        # 创建实时信息的滚动区域
        info_text_scroll = QScrollArea()
        info_text_scroll.setWidgetResizable(True)
        info_text_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        info_text_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        info_text_scroll.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        self.info_label = QLabel()
        self.info_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        self.info_label.setWordWrap(True)
        self.info_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.info_label.setStyleSheet("""
            QLabel {
                background-color: white;
                border: 1px solid #cccccc;
                border-radius: 4px;
                padding: 10px;
                font-family: Consolas, Monaco, monospace;
                font-size: 18px;
                color: #333333;
            }
        """)
        self.info_label.setText("等待数据...")
        
        info_text_scroll.setWidget(self.info_label)
        info_layout.addWidget(info_text_scroll)
        
        # 日志部分
        log_container = QWidget()
        log_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        log_layout = QVBoxLayout(log_container)
        log_layout.setContentsMargins(0, 0, 0, 0)
        log_layout.setSpacing(0)
        
        log_title = QLabel("日志")
        log_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        log_title.setStyleSheet("""
            QLabel {
                font-size: 20px;
                font-weight: bold;
                color: #333333;
                padding: 8px;
                background-color: #f5f5f5;
                border-bottom: 1px solid #ddd;
                border-radius: 4px;
            }
        """)
        log_layout.addWidget(log_title)
        
        # 创建日志的滚动区域
        log_text_scroll = QScrollArea()
        log_text_scroll.setWidgetResizable(True)
        log_text_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        log_text_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        log_text_scroll.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        self.log_label = QLabel()
        self.log_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
        self.log_label.setWordWrap(True)
        self.log_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.log_label.setStyleSheet("""
            QLabel {
                background-color: white;
                border: 1px solid #cccccc;
                border-radius: 4px;
                padding: 10px;
                font-family: Consolas, Monaco, monospace;
                font-size: 16px;
                color: #333333;
            }
        """)
        
        log_text_scroll.setWidget(self.log_label)
        log_layout.addWidget(log_text_scroll)
        
        # 添加所有组件到主布局，并设置拉伸因子
        layout.addWidget(info_container, 3)      # 增加拉伸因子
        layout.addWidget(log_container, 3)       # 增加拉伸因子
        
        # 设置信息面板的最小高度
        info_panel.setMinimumHeight(200)  # 减小最小高度
        
        return info_panel

    def add_log(self, message):
        """添加日志记录"""
        timestamp = time.strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        # 更新日志历史
        self.log_history.append(log_entry)
        # 保持最近的50条记录
        if len(self.log_history) > 50:
            self.log_history.pop(0)
        
        # 更新日志显示
        if hasattr(self, 'log_label'):
            self.log_label.setText("".join(self.log_history))

    def draw_bounding_box_on_image(self, frame, data_row=None, bubble_history=None):
        """修改绘制函数以添加轨迹和颜色标尺"""
        if data_row is None:
            return frame
            
        img = frame.copy()
        # 添加64像素的偏移
        center = (int(data_row['x0']) + 64, int(data_row['y0']) + 64)
        width = float(data_row['w_r'])
        height = float(data_row['h_r'])
        angle = -float(data_row['theta'])  # 修正角度方向
        
        # 绘制边界框
        img = draw_rotated_rectangle(img, center, width, height, angle)
        
        # 绘制历史轨迹
        if bubble_history is not None and len(bubble_history) > 1:
            # 计算速度用于颜色映射
            dt = 0.0001  # 帧间隔时间（秒）
            pixel_scale = 0.080128  # 像素尺度（毫米/像素）
            
            # 绘制历史轨迹点和线
            for i in range(1, len(bubble_history)):
                prev_center = (int(bubble_history[i-1]['x0']) + 64, int(bubble_history[i-1]['y0']) + 64)
                curr_center = (int(bubble_history[i]['x0']) + 64, int(bubble_history[i]['y0']) + 64)
                
                # 计算当前速度
                dx = (bubble_history[i]['x0'] - bubble_history[i-1]['x0']) * pixel_scale
                dy = (bubble_history[i]['y0'] - bubble_history[i-1]['y0']) * pixel_scale
                speed = np.sqrt(dx**2 + dy**2) / dt  # mm/s
                speed_ms = speed / 1000  # 转换为m/s
                
                # 将速度限制在0-1m/s范围内
                ratio = min(speed_ms, 1.0)
                # 修改颜色映射：红色表示速度快，蓝色表示速度慢
                color = (int(255 * ratio), 0, int(255 * (1 - ratio)))  # BGR格式，红色->蓝色
                
                # 绘制轨迹线
                cv2.line(img, prev_center, curr_center, color, 2)
                
                # 绘制轨迹点
                cv2.circle(img, curr_center, 3, color, -1)
        
        # 添加颜色标尺（设置为图像尺寸的20%）
        img_height, img_width = img.shape[:2]
        scale_height = int(img_height * 0.18)
        scale_width = int(img_width * 0.15)
        margin = 7
        
        # 创建颜色标尺
        scale_img = np.ones((scale_height, scale_width, 3), dtype=np.uint8) * 255
        for i in range(scale_height):
            ratio = i / scale_height
            color = (int(255 * (1 - ratio)), 0, int(255 * ratio))  # BGR格式，红色->蓝色
            scale_img[i, :] = color
            
        # 将颜色标尺添加到左下角
        y_offset = img_height - scale_height - margin*2
        x_offset = margin
        img[y_offset:y_offset+scale_height, x_offset:x_offset+scale_width] = scale_img
        
        # 添加速度标签
        font = cv2.FONT_HERSHEY_SIMPLEX
        font_scale = 0.4
        font_color = (0, 0, 0)  # 黑色
        font_thickness = 1
        
        # 添加最大速度标签 (1.0 m/s)
        cv2.putText(img, "1.0 m/s", (x_offset - 2, y_offset-5), 
                    font, font_scale, font_color, font_thickness)
        
        # 添加最小速度标签 (0.0 m/s)
        cv2.putText(img, "0.0 m/s", (x_offset - 2, y_offset+scale_height+10), 
                    font, font_scale, font_color, font_thickness)
        
        return img

    def change_liquid_color(self):
        """更改液相颜色"""
        if self.canvas_3d:
            self.canvas_3d.change_liquid_color()
            
    def change_bubble_color(self):
        """更改气泡颜色"""
        if self.canvas_3d:
            self.canvas_3d.change_bubble_color()

    def next_frame(self):
        """播放下一帧"""
        if not self.is_video_mode or not self.frames or len(self.frames) == 0:
            return
            
        # 计算下一帧索引
        next_index = self.current_frame_index + 1
        
        # 检查是否到达视频末尾
        if next_index >= len(self.frames):
            if self.loop_checkbox.isChecked():
                # 循环播放，回到第一帧
                next_index = 0
            else:
                # 停止播放
                self.stop_playback()
                return
        
        # 更新当前帧索引
        self.current_frame_index = next_index
        
        # 更新滑动条位置（不触发valueChanged信号）
        self.frame_slider.blockSignals(True)
        self.frame_slider.setValue(next_index)
        self.frame_slider.blockSignals(False)
        
        # 更新显示
        self.update_display(next_index)
    
    def start_playback(self):
        """开始播放视频"""
        if not self.is_video_mode or not self.frames or self.is_playing:
            return
            
        # 计算定时器间隔（毫秒）
        interval = int(1000 / (self.video_fps * self.playback_speed))
        
        # 启动定时器
        self.frame_timer.start(interval)
        self.is_playing = True
        
        # 更新播放按钮状态
        self.play_pause_btn.setText('暂停')
        self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/pause.png"))
        
        self.add_log(f"开始播放视频，帧率: {self.video_fps} FPS，播放速度: {self.playback_speed}x")
    
    def pause_playback(self):
        """暂停视频播放"""
        if not self.is_playing:
            return
            
        # 停止定时器
        self.frame_timer.stop()
        self.is_playing = False
        
        # 更新播放按钮状态
        self.play_pause_btn.setText('播放')
        self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/play.png"))
        
        self.add_log("暂停视频播放")
    
    def stop_playback(self):
        """停止视频播放并重置"""
        # 停止定时器
        self.frame_timer.stop()
        self.is_playing = False
        
        # 重置到第一帧
        self.current_frame_index = 0
        if self.frame_slider.isEnabled():
            self.frame_slider.setValue(0)
        
        # 更新播放按钮状态
        self.play_pause_btn.setText('播放')
        self.play_pause_btn.setIcon(QIcon("C:/Users/Administrator/Desktop/BFRM/icons/play.png"))
        
        # 停止所有动画（对于非视频模式）
        for movie in self.movies.values():
            if movie and movie.isValid() and movie.state() == QMovie.MovieState.Running:
                movie.stop()
        
        self.add_log("停止视频播放")

    def export_video(self):
        """导出当前处理好的视频"""
        if not self.frames or len(self.frames) == 0:
            QMessageBox.warning(self, "错误", "没有可用的视频帧可导出！")
            return
            
        try:
            # 暂停播放（如果正在播放）
            if self.is_playing:
                self.pause_playback()
                
            # 询问用户保存位置
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "保存视频",
                os.path.join(self.output_folder, "exported_video.mp4"),
                "视频文件 (*.mp4)"
            )
            
            if not file_path:
                return  # 用户取消
                
            self.progressBar.setValue(0)
            self.add_log(f"正在导出视频到: {file_path}")
            
            # 使用原始视频的帧率（如果是视频模式）
            fps = self.video_fps if self.is_video_mode and self.video_fps > 0 else 30
            
            # 保存视频
            height, width = self.frames[0].shape[:2]
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(file_path, fourcc, fps, (width, height))
            
            total_frames = len(self.frames)
            for i, frame in enumerate(self.frames):
                out.write(frame)
                if i % 10 == 0 or i == total_frames - 1:  # 每10帧或最后一帧更新进度
                    self.progressBar.setValue(int(100 * (i + 1) / total_frames))
                    QApplication.processEvents()  # 更新UI
                    
            out.release()
            
            self.statusBar.showMessage(f"视频已成功导出到: {file_path}")
            self.add_log(f"视频导出完成: {file_path}")
            
        except Exception as e:
            error_msg = f"导出视频时出错: {str(e)}"
            self.add_log(error_msg)
            QMessageBox.critical(self, "错误", error_msg)
            self.progressBar.setValue(0)
            import traceback
            traceback.print_exc()